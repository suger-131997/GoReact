package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type HandlerInfo struct {
	Name string
}

func main() {
	pageDir := "./page"
	files, err := os.ReadDir(pageDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read page dir: %v\n", err)
		os.Exit(1)
	}

	var handlers []HandlerInfo

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") {
			continue
		}

		path := filepath.Join(pageDir, file.Name())
		h, err := findHandlers(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to process file %s: %v\n", path, err)
			continue
		}
		handlers = append(handlers, h...)
	}

	if err := generateGenGo(handlers); err != nil {
		fmt.Fprintf(os.Stderr, "failed to generate gen/gen.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Generated gen/gen.go")
}

func findHandlers(path string) ([]HandlerInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var handlers []HandlerInfo

	ast.Inspect(node, func(n ast.Node) bool {
		switch gd := n.(type) {
		case *ast.GenDecl:
			if gd.Tok != token.VAR {
				return true
			}
			for _, spec := range gd.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok {
					continue
				}
				for i, val := range vs.Values {
					if isPageHandler(val) {
						if i < len(vs.Names) {
							handlers = append(handlers, HandlerInfo{
								Name: vs.Names[i].Name,
							})
						}
					}
				}
			}
		case *ast.FuncDecl:
			// func NewXXXHandler() *handler.PageHandler[T]
			if gd.Type.Results == nil || len(gd.Type.Results.List) != 1 {
				return true
			}
			retType := gd.Type.Results.List[0].Type
			if isPageHandlerType(retType) {
				handlers = append(handlers, HandlerInfo{
					Name: gd.Name.Name + "()",
				})
			}
		}
		return true
	})

	return handlers, nil
}

func isPageHandlerType(expr ast.Expr) bool {
	// *handler.PageHandler[T]
	star, ok := expr.(*ast.StarExpr)
	if !ok {
		return false
	}

	// PageHandler[T]
	indexExpr, ok := star.X.(*ast.IndexExpr)
	if !ok {
		return false
	}

	selExpr, ok := indexExpr.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}

	xIdent, ok := selExpr.X.(*ast.Ident)
	if !ok {
		return false
	}

	return xIdent.Name == "handler" && selExpr.Sel.Name == "PageHandler"
}

func isPageHandler(expr ast.Expr) bool {
	// &handler.PageHandler[T]{...}
	unary, ok := expr.(*ast.UnaryExpr)
	if !ok || unary.Op != token.AND {
		return false
	}

	composite, ok := unary.X.(*ast.CompositeLit)
	if !ok {
		return false
	}

	// PageHandler[T] (IndexExpr) or PageHandler (SelectorExpr if not generic, but here it is generic)
	indexExpr, ok := composite.Type.(*ast.IndexExpr)
	if !ok {
		return false
	}

	selExpr, ok := indexExpr.X.(*ast.SelectorExpr)
	if !ok {
		return false
	}

	xIdent, ok := selExpr.X.(*ast.Ident)
	if !ok {
		return false
	}

	return xIdent.Name == "handler" && selExpr.Sel.Name == "PageHandler"
}

func generateGenGo(handlers []HandlerInfo) error {
	const tmpl = `// Code generated by gen-js-builder. DO NOT EDIT.
//go:build !prod

package main

import (
	"os"
	"path/filepath"

	"goreact/internal/builder"
	"goreact/page"
)

func main() {
	b := builder.NewProdBuilder()
{{- range .Handlers }}
	if err := build(b, page.{{ .Name }}.EntryPoint()); err != nil {
		panic(err)
	}
{{- end }}
}

func build(b *builder.Builder, entryPoint string) error {
	outputDir := "./.output"
	if _, err := os.Stat(outputDir); os.IsNotExist(err) {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return err
		}
	}

	js, err := b.Build(entryPoint)
	if err != nil {
		return err
	}

	fileName := entryPoint[:len(entryPoint)-len(filepath.Ext(entryPoint))] + ".js"
	outputPath := filepath.Join(outputDir, fileName)

	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return err
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := f.WriteString(js); err != nil {
		return err
	}

	return nil
}
`
	t, err := template.New("gen").Parse(tmpl)
	if err != nil {
		return err
	}

	outDir := "./gen"
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return err
	}

	f, err := os.Create(filepath.Join(outDir, "gen.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	return t.Execute(f, map[string]interface{}{
		"Handlers": handlers,
	})
}
