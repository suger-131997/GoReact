package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

func main() {
	pageDir := "./page"
	files, err := os.ReadDir(pageDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read page dir: %v\n", err)
		os.Exit(1)
	}

	var allTsCode strings.Builder
	allTsCode.WriteString("// Code generated by gen-types. DO NOT EDIT.\n\n")

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") {
			continue
		}

		path := filepath.Join(pageDir, file.Name())
		tsCode, err := processFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "failed to process file %s: %v\n", path, err)
			continue
		}
		allTsCode.WriteString(tsCode)
	}

	outPath := "types.gen.ts"
	err = os.WriteFile(outPath, []byte(allTsCode.String()), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to write types file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", outPath)
}

func processFile(path string) (string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return "", err
	}

	// 1. Find the struct names from *handler.PageHandler[T] constructors
	targetStructs := make(map[string]bool)
	ast.Inspect(node, func(n ast.Node) bool {
		fd, ok := n.(*ast.FuncDecl)
		if !ok || fd.Type.Results == nil || len(fd.Type.Results.List) == 0 {
			return true
		}

		// Check return type: *handler.PageHandler[T]
		retType := fd.Type.Results.List[0].Type
		starExpr, ok := retType.(*ast.StarExpr)
		if !ok {
			return true
		}

		idxExpr, ok := starExpr.X.(*ast.IndexExpr)
		if !ok {
			return true
		}

		selExpr, ok := idxExpr.X.(*ast.SelectorExpr)
		if !ok {
			return true
		}

		xIdent, ok := selExpr.X.(*ast.Ident)
		if !ok || xIdent.Name != "handler" || selExpr.Sel.Name != "PageHandler" {
			return true
		}

		// Get T
		tIdent, ok := idxExpr.Index.(*ast.Ident)
		if ok {
			targetStructs[tIdent.Name] = true
		}

		return true
	})

	if len(targetStructs) == 0 {
		return "", nil
	}

	// Collect all struct types in the file
	allStructs := make(map[string]*ast.StructType)
	ast.Inspect(node, func(n ast.Node) bool {
		gd, ok := n.(*ast.GenDecl)
		if !ok || gd.Tok != token.TYPE {
			return true
		}
		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if st, ok := ts.Type.(*ast.StructType); ok {
				allStructs[ts.Name.Name] = st
			}
		}
		return true
	})

	// Find all reachable structs starting from targetStructs
	reachable := make(map[string]bool)
	var collectReachable func(typeName string)
	collectReachable = func(typeName string) {
		if reachable[typeName] {
			return
		}
		st, ok := allStructs[typeName]
		if !ok {
			return
		}
		reachable[typeName] = true
		for _, field := range st.Fields.List {
			findIdentNames(field.Type, func(name string) {
				if _, ok := allStructs[name]; ok {
					collectReachable(name)
				}
			})
		}
	}

	for ts := range targetStructs {
		collectReachable(ts)
	}

	// 2. Extract struct definitions
	var tsCode strings.Builder

	ast.Inspect(node, func(n ast.Node) bool {
		gd, ok := n.(*ast.GenDecl)
		if !ok || gd.Tok != token.TYPE {
			return true
		}

		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			if !reachable[ts.Name.Name] {
				continue
			}

			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				continue
			}

			tsCode.WriteString(fmt.Sprintf("export type %s = {\n", ts.Name.Name))
			for _, field := range st.Fields.List {
				if len(field.Names) == 0 {
					continue
				}

				name := field.Names[0].Name
				// Use JSON tag if present
				if field.Tag != nil {
					tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
					if jsonTag := tag.Get("json"); jsonTag != "" {
						name = strings.Split(jsonTag, ",")[0]
					}
				}

				tsType := goTypeToTsType(field.Type, allStructs)
				tsCode.WriteString(fmt.Sprintf("  %s: %s;\n", name, tsType))
			}
			tsCode.WriteString("}\n\n")
		}
		return true
	})

	return tsCode.String(), nil
}

func findIdentNames(expr ast.Expr, cb func(string)) {
	switch t := expr.(type) {
	case *ast.Ident:
		cb(t.Name)
	case *ast.ArrayType:
		findIdentNames(t.Elt, cb)
	case *ast.StarExpr:
		findIdentNames(t.X, cb)
	case *ast.MapType:
		findIdentNames(t.Key, cb)
		findIdentNames(t.Value, cb)
	}
}

func goTypeToTsType(expr ast.Expr, knownStructs map[string]*ast.StructType) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return "string"
		case "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64":
			return "number"
		case "bool":
			return "boolean"
		default:
			if _, ok := knownStructs[t.Name]; ok {
				return t.Name
			}
			return "any"
		}
	case *ast.ArrayType:
		return goTypeToTsType(t.Elt, knownStructs) + "[]"
	case *ast.StarExpr:
		return goTypeToTsType(t.X, knownStructs)
	case *ast.MapType:
		return fmt.Sprintf("{ [key: %s]: %s }", goTypeToTsType(t.Key, knownStructs), goTypeToTsType(t.Value, knownStructs))
	default:
		return "any"
	}
}
